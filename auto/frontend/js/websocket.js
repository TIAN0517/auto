// WebSocketÂç≥ÊôÇÈÄöË®äÊ®°ÁµÑ - 4DÁßëÊäÄÈ¢®Ê†ºËá™ÂãïË¥äÂä©Á≥ªÁµ±
// Real-time Communication Module

// WebSocketÈÖçÁΩÆ
const WebSocketConfig = {
    RECONNECT_INTERVAL: 3000,
    MAX_RECONNECT_ATTEMPTS: 10,
    HEARTBEAT_INTERVAL: 30000,
    MESSAGE_TYPES: {
        PAYMENT_STATUS: 'payment_status',
        TRANSACTION_UPDATE: 'transaction_update',
        SYSTEM_NOTIFICATION: 'system_notification',
        USER_MESSAGE: 'user_message',
        HEARTBEAT: 'heartbeat',
        AUTH: 'auth',
        SUBSCRIBE: 'subscribe',
        UNSUBSCRIBE: 'unsubscribe'
    },
    CHANNELS: {
        PAYMENTS: 'payments',
        TRANSACTIONS: 'transactions',
        NOTIFICATIONS: 'notifications',
        SYSTEM: 'system'
    }
};

// WebSocketÁÆ°ÁêÜÂô®
class WebSocketManager {
    constructor() {
        this.ws = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.subscriptions = new Set();
        this.messageHandlers = new Map();
        this.heartbeatTimer = null;
        this.reconnectTimer = null;
        this.userId = null;
        this.token = null;
        this.init();
    }

    init() {
        this.loadUserInfo();
        this.setupEventHandlers();
        this.connect();
        console.log('üîå WebSocketÁÆ°ÁêÜÂô®Â∑≤ÂàùÂßãÂåñ');
    }

    // ËºâÂÖ•Áî®Êà∂‰ø°ÊÅØ
    loadUserInfo() {
        this.token = localStorage.getItem('token');
        this.userId = localStorage.getItem('userId');
    }

    // Ë®≠ÁΩÆ‰∫ã‰ª∂ËôïÁêÜÂô®
    setupEventHandlers() {
        // Áõ£ËÅΩÈ†ÅÈù¢ÂèØË¶ãÊÄßËÆäÂåñ
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.pauseHeartbeat();
            } else {
                this.resumeHeartbeat();
                if (!this.isConnected) {
                    this.connect();
                }
            }
        });

        // Áõ£ËÅΩÁ∂≤Ë∑ØÁãÄÊÖãËÆäÂåñ
        window.addEventListener('online', () => {
            console.log('üåê Á∂≤Ë∑ØÂ∑≤ÈÄ£Êé•ÔºåÂòóË©¶ÈáçÊñ∞ÈÄ£Êé•WebSocket');
            this.connect();
        });

        window.addEventListener('offline', () => {
            console.log('üåê Á∂≤Ë∑ØÂ∑≤Êñ∑Á∑ö');
            this.disconnect();
        });

        // Áõ£ËÅΩÈ†ÅÈù¢Âç∏Ëºâ
        window.addEventListener('beforeunload', () => {
            this.disconnect();
        });
    }

    // ÈÄ£Êé•WebSocket
    connect() {
        if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {
            return;
        }

        try {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            console.log('üîå Ê≠£Âú®ÈÄ£Êé•WebSocket:', wsUrl);
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = this.onOpen.bind(this);
            this.ws.onmessage = this.onMessage.bind(this);
            this.ws.onclose = this.onClose.bind(this);
            this.ws.onerror = this.onError.bind(this);
            
        } catch (error) {
            console.error('WebSocketÈÄ£Êé•Â§±Êïó:', error);
            this.scheduleReconnect();
        }
    }

    // ÈÄ£Êé•ÊàêÂäü
    onOpen(event) {
        console.log('‚úÖ WebSocketÈÄ£Êé•ÊàêÂäü');
        this.isConnected = true;
        this.reconnectAttempts = 0;
        
        // ÁôºÈÄÅË™çË≠â‰ø°ÊÅØ
        this.authenticate();
        
        // ÈáçÊñ∞Ë®ÇÈñ±È†ªÈÅì
        this.resubscribeChannels();
        
        // ÈñãÂßãÂøÉË∑≥
        this.startHeartbeat();
        
        // Ëß∏ÁôºÈÄ£Êé•ÊàêÂäü‰∫ã‰ª∂
        this.emit('connected', { timestamp: Date.now() });
        
        // Êõ¥Êñ∞UIÁãÄÊÖã
        this.updateConnectionStatus(true);
    }

    // Êé•Êî∂Ê∂àÊÅØ
    onMessage(event) {
        try {
            const message = JSON.parse(event.data);
            console.log('üì® Êî∂Âà∞WebSocketÊ∂àÊÅØ:', message);
            
            this.handleMessage(message);
            
        } catch (error) {
            console.error('Ëß£ÊûêWebSocketÊ∂àÊÅØÂ§±Êïó:', error, event.data);
        }
    }

    // ÈÄ£Êé•ÈóúÈñâ
    onClose(event) {
        console.log('üîå WebSocketÈÄ£Êé•Â∑≤ÈóúÈñâ:', event.code, event.reason);
        this.isConnected = false;
        this.stopHeartbeat();
        
        // Êõ¥Êñ∞UIÁãÄÊÖã
        this.updateConnectionStatus(false);
        
        // Ëß∏ÁôºÊñ∑Á∑ö‰∫ã‰ª∂
        this.emit('disconnected', { 
            code: event.code, 
            reason: event.reason,
            timestamp: Date.now()
        });
        
        // Â¶ÇÊûú‰∏çÊòØ‰∏ªÂãïÊñ∑Á∑öÔºåÂòóË©¶ÈáçÈÄ£
        if (event.code !== 1000) {
            this.scheduleReconnect();
        }
    }

    // ÈÄ£Êé•ÈåØË™§
    onError(error) {
        console.error('‚ùå WebSocketÈåØË™§:', error);
        this.emit('error', { error, timestamp: Date.now() });
    }

    // ËôïÁêÜÊ∂àÊÅØ
    handleMessage(message) {
        const { type, data, channel } = message;
        
        switch (type) {
            case WebSocketConfig.MESSAGE_TYPES.PAYMENT_STATUS:
                this.handlePaymentStatus(data);
                break;
                
            case WebSocketConfig.MESSAGE_TYPES.TRANSACTION_UPDATE:
                this.handleTransactionUpdate(data);
                break;
                
            case WebSocketConfig.MESSAGE_TYPES.SYSTEM_NOTIFICATION:
                this.handleSystemNotification(data);
                break;
                
            case WebSocketConfig.MESSAGE_TYPES.USER_MESSAGE:
                this.handleUserMessage(data);
                break;
                
            case WebSocketConfig.MESSAGE_TYPES.HEARTBEAT:
                this.handleHeartbeat(data);
                break;
                
            default:
                console.log('Êú™Áü•Ê∂àÊÅØÈ°ûÂûã:', type, data);
        }
        
        // Ëß∏ÁôºÈÄöÁî®Ê∂àÊÅØ‰∫ã‰ª∂
        this.emit('message', message);
        
        // Ëß∏ÁôºÁâπÂÆöÈ°ûÂûã‰∫ã‰ª∂
        this.emit(type, data);
        
        // Ëß∏ÁôºÈ†ªÈÅì‰∫ã‰ª∂
        if (channel) {
            this.emit(`channel:${channel}`, data);
        }
    }

    // ËôïÁêÜÊîØ‰ªòÁãÄÊÖãÊõ¥Êñ∞
    handlePaymentStatus(data) {
        console.log('üí≥ ÊîØ‰ªòÁãÄÊÖãÊõ¥Êñ∞:', data);
        
        // Êõ¥Êñ∞ÊîØ‰ªòÈ†ÅÈù¢ÁãÄÊÖã
        if (window.JySpeedPay && window.JySpeedPay.manager()) {
            document.dispatchEvent(new CustomEvent('speedpay:statusUpdate', {
                detail: data
            }));
        }
        
        // È°ØÁ§∫ÈÄöÁü•
        this.showPaymentNotification(data);
    }

    // ËôïÁêÜ‰∫§ÊòìÊõ¥Êñ∞
    handleTransactionUpdate(data) {
        console.log('üìä ‰∫§ÊòìÊõ¥Êñ∞:', data);
        
        // Êõ¥Êñ∞‰∫§ÊòìÂàóË°®
        this.updateTransactionList(data);
        
        // Êõ¥Êñ∞Áµ±Ë®àÊï∏Êìö
        this.updateStatistics(data);
    }

    // ËôïÁêÜÁ≥ªÁµ±ÈÄöÁü•
    handleSystemNotification(data) {
        console.log('üîî Á≥ªÁµ±ÈÄöÁü•:', data);
        
        // È°ØÁ§∫Á≥ªÁµ±ÈÄöÁü•
        if (window.JyMainApp && window.JyMainApp.app()) {
            window.JyMainApp.app().showNotification(data.message, data.type || 'info');
        }
    }

    // ËôïÁêÜÁî®Êà∂Ê∂àÊÅØ
    handleUserMessage(data) {
        console.log('üë§ Áî®Êà∂Ê∂àÊÅØ:', data);
        
        // È°ØÁ§∫Áî®Êà∂Ê∂àÊÅØ
        this.showUserMessage(data);
    }

    // ËôïÁêÜÂøÉË∑≥
    handleHeartbeat(data) {
        // ÂõûÊáâÂøÉË∑≥
        this.send({
            type: WebSocketConfig.MESSAGE_TYPES.HEARTBEAT,
            data: { timestamp: Date.now() }
        });
    }

    // ÁôºÈÄÅË™çË≠â‰ø°ÊÅØ
    authenticate() {
        if (this.token) {
            this.send({
                type: WebSocketConfig.MESSAGE_TYPES.AUTH,
                data: {
                    token: this.token,
                    userId: this.userId
                }
            });
        }
    }

    // Ë®ÇÈñ±È†ªÈÅì
    subscribe(channel) {
        if (this.subscriptions.has(channel)) {
            return;
        }
        
        this.subscriptions.add(channel);
        
        if (this.isConnected) {
            this.send({
                type: WebSocketConfig.MESSAGE_TYPES.SUBSCRIBE,
                data: { channel }
            });
        }
        
        console.log('üì∫ Â∑≤Ë®ÇÈñ±È†ªÈÅì:', channel);
    }

    // ÂèñÊ∂àË®ÇÈñ±È†ªÈÅì
    unsubscribe(channel) {
        if (!this.subscriptions.has(channel)) {
            return;
        }
        
        this.subscriptions.delete(channel);
        
        if (this.isConnected) {
            this.send({
                type: WebSocketConfig.MESSAGE_TYPES.UNSUBSCRIBE,
                data: { channel }
            });
        }
        
        console.log('üì∫ Â∑≤ÂèñÊ∂àË®ÇÈñ±È†ªÈÅì:', channel);
    }

    // ÈáçÊñ∞Ë®ÇÈñ±ÊâÄÊúâÈ†ªÈÅì
    resubscribeChannels() {
        this.subscriptions.forEach(channel => {
            this.send({
                type: WebSocketConfig.MESSAGE_TYPES.SUBSCRIBE,
                data: { channel }
            });
        });
    }

    // ÁôºÈÄÅÊ∂àÊÅØ
    send(message) {
        if (!this.isConnected || !this.ws) {
            console.warn('WebSocketÊú™ÈÄ£Êé•ÔºåÁÑ°Ê≥ïÁôºÈÄÅÊ∂àÊÅØ:', message);
            return false;
        }
        
        try {
            this.ws.send(JSON.stringify(message));
            return true;
        } catch (error) {
            console.error('ÁôºÈÄÅWebSocketÊ∂àÊÅØÂ§±Êïó:', error);
            return false;
        }
    }

    // ÈñãÂßãÂøÉË∑≥
    startHeartbeat() {
        this.stopHeartbeat();
        
        this.heartbeatTimer = setInterval(() => {
            if (this.isConnected) {
                this.send({
                    type: WebSocketConfig.MESSAGE_TYPES.HEARTBEAT,
                    data: { timestamp: Date.now() }
                });
            }
        }, WebSocketConfig.HEARTBEAT_INTERVAL);
    }

    // ÂÅúÊ≠¢ÂøÉË∑≥
    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }

    // Êö´ÂÅúÂøÉË∑≥
    pauseHeartbeat() {
        this.stopHeartbeat();
    }

    // ÊÅ¢Âæ©ÂøÉË∑≥
    resumeHeartbeat() {
        if (this.isConnected) {
            this.startHeartbeat();
        }
    }

    // ÂÆâÊéíÈáçÈÄ£
    scheduleReconnect() {
        if (this.reconnectAttempts >= WebSocketConfig.MAX_RECONNECT_ATTEMPTS) {
            console.error('‚ùå WebSocketÈáçÈÄ£Ê¨°Êï∏Â∑≤ÈÅî‰∏äÈôê');
            this.emit('maxReconnectAttemptsReached');
            return;
        }
        
        this.reconnectAttempts++;
        const delay = Math.min(WebSocketConfig.RECONNECT_INTERVAL * this.reconnectAttempts, 30000);
        
        console.log(`üîÑ Â∞áÂú® ${delay}ms ÂæåÂòóË©¶Á¨¨ ${this.reconnectAttempts} Ê¨°ÈáçÈÄ£`);
        
        this.reconnectTimer = setTimeout(() => {
            this.connect();
        }, delay);
    }

    // Êñ∑ÈñãÈÄ£Êé•
    disconnect() {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
        
        this.stopHeartbeat();
        
        if (this.ws) {
            this.ws.close(1000, '‰∏ªÂãïÊñ∑Á∑ö');
            this.ws = null;
        }
        
        this.isConnected = false;
        this.updateConnectionStatus(false);
    }

    // Êõ¥Êñ∞ÈÄ£Êé•ÁãÄÊÖãÈ°ØÁ§∫
    updateConnectionStatus(connected) {
        const statusElements = document.querySelectorAll('.connection-status');
        statusElements.forEach(element => {
            element.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
            element.innerHTML = connected 
                ? '<i class="fas fa-wifi"></i> Â∑≤ÈÄ£Êé•'
                : '<i class="fas fa-wifi-slash"></i> Â∑≤Êñ∑Á∑ö';
        });
        
        // Êõ¥Êñ∞Â∞éËà™Ê¨ÑÁãÄÊÖã
        const navStatus = document.querySelector('.nav-status');
        if (navStatus) {
            navStatus.className = `nav-status ${connected ? 'online' : 'offline'}`;
        }
    }

    // È°ØÁ§∫ÊîØ‰ªòÈÄöÁü•
    showPaymentNotification(data) {
        const { status, amount, method, orderId } = data;
        
        let message = '';
        let type = 'info';
        
        switch (status) {
            case 'completed':
                message = `ÊîØ‰ªòÊàêÂäüÔºÅÈáëÈ°çÔºö${this.formatAmount(amount)}`;
                type = 'success';
                break;
            case 'failed':
                message = `ÊîØ‰ªòÂ§±ÊïóÔºåË®ÇÂñÆÔºö${orderId}`;
                type = 'error';
                break;
            case 'pending':
                message = `ÊîØ‰ªòËôïÁêÜ‰∏≠ÔºåË´ãÁ®çÂÄô...`;
                type = 'info';
                break;
            case 'expired':
                message = `ÊîØ‰ªòÂ∑≤ÈÅéÊúüÔºåË®ÇÂñÆÔºö${orderId}`;
                type = 'warning';
                break;
        }
        
        if (window.JyMainApp && window.JyMainApp.app()) {
            window.JyMainApp.app().showNotification(message, type);
        }
    }

    // Êõ¥Êñ∞‰∫§ÊòìÂàóË°®
    updateTransactionList(data) {
        const transactionList = document.querySelector('.transaction-list');
        if (!transactionList) return;
        
        // Ê∑ªÂä†Êñ∞‰∫§ÊòìÊàñÊõ¥Êñ∞ÁèæÊúâ‰∫§Êòì
        const existingItem = transactionList.querySelector(`[data-transaction-id="${data.id}"]`);
        
        if (existingItem) {
            // Êõ¥Êñ∞ÁèæÊúâÈ†ÖÁõÆ
            this.updateTransactionItem(existingItem, data);
        } else {
            // Ê∑ªÂä†Êñ∞È†ÖÁõÆ
            const newItem = this.createTransactionItem(data);
            transactionList.insertBefore(newItem, transactionList.firstChild);
        }
    }

    // ÂâµÂª∫‰∫§ÊòìÈ†ÖÁõÆ
    createTransactionItem(data) {
        const item = document.createElement('div');
        item.className = 'transaction-item';
        item.setAttribute('data-transaction-id', data.id);
        
        item.innerHTML = `
            <div class="transaction-info">
                <div class="transaction-id">#${data.id}</div>
                <div class="transaction-amount">${this.formatAmount(data.amount)}</div>
                <div class="transaction-method">${data.method}</div>
                <div class="transaction-status status-${data.status}">${this.getStatusText(data.status)}</div>
                <div class="transaction-time">${this.formatDate(data.created_at)}</div>
            </div>
        `;
        
        return item;
    }

    // Êõ¥Êñ∞‰∫§ÊòìÈ†ÖÁõÆ
    updateTransactionItem(item, data) {
        const statusElement = item.querySelector('.transaction-status');
        if (statusElement) {
            statusElement.className = `transaction-status status-${data.status}`;
            statusElement.textContent = this.getStatusText(data.status);
        }
    }

    // Êõ¥Êñ∞Áµ±Ë®àÊï∏Êìö
    updateStatistics(data) {
        // Êõ¥Êñ∞Á∏ΩÈáëÈ°ç
        const totalAmountElement = document.querySelector('.total-amount');
        if (totalAmountElement && data.totalAmount) {
            totalAmountElement.textContent = this.formatAmount(data.totalAmount);
        }
        
        // Êõ¥Êñ∞‰∫§ÊòìÊï∏Èáè
        const transactionCountElement = document.querySelector('.transaction-count');
        if (transactionCountElement && data.transactionCount) {
            transactionCountElement.textContent = data.transactionCount;
        }
    }

    // È°ØÁ§∫Áî®Êà∂Ê∂àÊÅØ
    showUserMessage(data) {
        // ÂèØ‰ª•Âú®ÈÄôË£°ÂØ¶ÁèæËÅäÂ§©ÂäüËÉΩÊàñÁî®Êà∂ÈÄöÁü•
        console.log('Áî®Êà∂Ê∂àÊÅØ:', data);
    }

    // ‰∫ã‰ª∂ÁôºÂ∞ÑÂô®
    emit(event, data) {
        const handlers = this.messageHandlers.get(event);
        if (handlers) {
            handlers.forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    console.error(`‰∫ã‰ª∂ËôïÁêÜÂô®ÈåØË™§ (${event}):`, error);
                }
            });
        }
    }

    // Ê∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
    on(event, handler) {
        if (!this.messageHandlers.has(event)) {
            this.messageHandlers.set(event, []);
        }
        this.messageHandlers.get(event).push(handler);
    }

    // ÁßªÈô§‰∫ã‰ª∂Áõ£ËÅΩÂô®
    off(event, handler) {
        const handlers = this.messageHandlers.get(event);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index > -1) {
                handlers.splice(index, 1);
            }
        }
    }

    // Â∑•ÂÖ∑ÊñπÊ≥ï
    formatAmount(amount) {
        return new Intl.NumberFormat('zh-TW', {
            style: 'currency',
            currency: 'TWD',
            minimumFractionDigits: 0
        }).format(amount);
    }

    formatDate(dateString) {
        const date = new Date(dateString);
        return new Intl.DateTimeFormat('zh-TW', {
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        }).format(date);
    }

    getStatusText(status) {
        const statusTexts = {
            'pending': 'ÂæÖËôïÁêÜ',
            'processing': 'ËôïÁêÜ‰∏≠',
            'completed': 'Â∑≤ÂÆåÊàê',
            'failed': 'Â§±Êïó',
            'expired': 'Â∑≤ÈÅéÊúü',
            'cancelled': 'Â∑≤ÂèñÊ∂à'
        };
        return statusTexts[status] || 'Êú™Áü•';
    }

    // Áç≤ÂèñÈÄ£Êé•ÁãÄÊÖã
    getConnectionStatus() {
        return {
            connected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            subscriptions: Array.from(this.subscriptions)
        };
    }
}

// WebSocketÂ∑•ÂÖ∑ÂáΩÊï∏
const WebSocketUtils = {
    // Ê™¢Êü•WebSocketÊîØÊè¥
    isSupported() {
        return 'WebSocket' in window;
    },
    
    // Áç≤ÂèñWebSocketÁãÄÊÖãÊñáÂ≠ó
    getReadyStateText(readyState) {
        const states = {
            0: 'CONNECTING',
            1: 'OPEN',
            2: 'CLOSING',
            3: 'CLOSED'
        };
        return states[readyState] || 'UNKNOWN';
    }
};

// ÂàùÂßãÂåñWebSocketÁÆ°ÁêÜÂô®
let wsManager;
document.addEventListener('DOMContentLoaded', () => {
    if (WebSocketUtils.isSupported()) {
        wsManager = new WebSocketManager();
        
        // Ëá™ÂãïË®ÇÈñ±Âü∫Êú¨È†ªÈÅì
        wsManager.subscribe(WebSocketConfig.CHANNELS.PAYMENTS);
        wsManager.subscribe(WebSocketConfig.CHANNELS.NOTIFICATIONS);
        
        // Â¶ÇÊûúÊòØÁÆ°ÁêÜÂì°È†ÅÈù¢ÔºåË®ÇÈñ±Á≥ªÁµ±È†ªÈÅì
        if (window.location.pathname.includes('admin')) {
            wsManager.subscribe(WebSocketConfig.CHANNELS.SYSTEM);
            wsManager.subscribe(WebSocketConfig.CHANNELS.TRANSACTIONS);
        }
    } else {
        console.warn('‚ö†Ô∏è ÁÄèË¶ΩÂô®‰∏çÊîØÊè¥WebSocket');
    }
});

// Â∞éÂá∫ÂÖ®Â±ÄÂ∞çË±°
window.JyWebSocket = {
    manager: () => wsManager,
    utils: WebSocketUtils,
    config: WebSocketConfig
};

console.log('üîå WebSocketÊ®°ÁµÑÂ∑≤ËºâÂÖ•');